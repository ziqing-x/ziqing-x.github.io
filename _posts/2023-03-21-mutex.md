---
title: c++常用锁介绍
tags: [锁]
category: c++
description: 互斥锁、条件锁、自旋锁、读写锁、递归锁
---

## 概述
c++常见的锁有互斥锁、条件锁、自旋锁、读写锁、递归锁；通过这篇文章，你应该掌握什么场景使用什么锁。

## 🔐 互斥锁
### std::mutex

+ 头文件 

```c++ 
#include <mutex>
```

+ 常用成员方法

```c++
lock(); // 加锁，并且只有一个线程获得锁的所有权，它具有阻塞线程的作用
try_lock(); // 和lock的区别就是，不阻塞，会立即返回
unlock(); // 解锁
```

+ 例子

```c++
#include <mutex>
#include <iostream>
#include <thread>
#include <unistd.h>

std::mutex mtx;

int main() {
    std::thread t1([](){
        sleep(2); // 休眠2秒，让t2线程先拿到锁
        while (true) {
            mtx.lock(); // t2或者t3持有锁未解锁t1就会一直阻塞
            std::cout<< "t1已上锁\n";
            mtx.unlock();
            std::cout<< "t1已解锁\n";
        }
    });

    std::thread t2([](){
        // 上锁后永远不解锁
        mtx.lock();
        while (true){
            std::cout<< "t2已上锁\n";
            sleep(1);
        }
        mtx.unlock();
    });
    
    std::thread t3([](){
        while (true) {
            // 尝试上锁，立刻返回，不阻塞，如果成功返回true，失败返回false
            auto ret = mtx.try_lock();
            if (ret) {
                std::cout<< "t3已上锁\n";
                mtx.unlock();
                std::cout<< "t3已解锁\n";
            } else {
                std::cout<< "t3上锁失败\n";
            }
            sleep(1);
        }
    });

    if (t1.joinable()) {
        t1.join();
    }
    if (t2.joinable()) {
        t2.join();
    }
    if (t3.joinable()) {
        t3.join();
    }

    return 0;
}

```

### std::lock_guard
lock_guard 使用了 RAII 技术，在构造的时候上锁，析构的时候unlock()，用来解决std::mutex在lock()或者try_lock()成功后还未来得及unlock()就退出或者异常的问题。

+ 头文件 

```c++ 
#include <mutex>
```

+ 例子

```c++
#include <mutex>
#include <iostream>
#include <thread>
#include <unistd.h>

std::mutex mtx;

int main() {
    std::thread t1([](){
        sleep(2); // 休眠2秒，让t2线程先拿到锁
        while (true) {
            std::lock_guard<std::mutex> lck(mtx);// t2或者t3持有锁未解锁t1就会一直阻塞
            std::cout<< "t1已上锁\n";
            break;
        }
        std::cout<< "t1已解锁\n";
    });

    std::thread t2([](){
        while (true){
            std::lock_guard<std::mutex> lck(mtx);
            std::cout<< "t2已上锁\n";
            sleep(5);
            break;

        }
        std::cout<< "t2已解锁\n";
    });
    
    if (t1.joinable()) {
        t1.join();
    }
    if (t2.joinable()) {
        t2.join();
    }

    return 0;
}
```

### std::unique_lock
lock_guard只能在析构的时候解锁，不提供unlock接口，不够方便，unique_lock提供lock和unlock接口，更灵活，但是unique_lock比lock_guard效率上差一点，内存占用多一点。
+ 头文件

```c++ 
#include <mutex>
```

+ 常用成员方法

```c++
lock();
unlock();
```

+ 例子

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <unistd.h>

std::mutex mtx;

int main() {
    std::thread t([](){
        while (true) {
            std::unique_lock<std::mutex> lck(mtx);
            std::cout << "t已上锁\n";
            lck.unlock();
            std::cout << "t临时解锁\n";
            lck.lock();
            std::cout << "t再次上锁\n";
            break;
        }
        std::cout << "t解锁\n";
    });
    
    usleep(100); // 让子线程先拿到锁
    std::unique_lock<std::mutex> lck(mtx);
    std::cout << "Hello world" << std::endl;
    if (t.joinable()) {
        t.join();
    }
    return 0;
}
```

***
## 🔐 条件锁
### std::condition_variable
条件变量，某一个线程因为某个条件未满足时可以使用条件变量使该线程处于阻塞状态，一旦条件满足，以“信号量”的方式唤醒一个因为该条件而被阻塞的线程。只能与互斥锁配合使用
+ 头文件 

```c++ 
#include <condition_variable>
#include <mutex>
```

+ 常用成员方法

```c++
wait(); // 阻塞当前线程直到条件满足被唤醒
wait_for(); // 阻塞当前线程，直到唤醒条件变量或在指定的超时时间之后
wait_until(); // 阻塞当前线程，直到唤醒条件变量或直到达到指定的时间点为止
notify_one(); // 通知一个正在等待的线程
notify_all(); // 通知所有正在等待的线程
```

+ 例子1
多线程同步

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;

void func() {
    std::unique_lock<std::mutex> ulck(mtx);
    std::cout << "子线程等待中..." << std::endl;
#if 1 // 一直阻塞等待
    cv.wait(ulck);
#elif 0// 只等待20秒
    cv.wait_for(ulck, std::chrono::seconds(20) == std::cv_status::timeout);
#else // 等到指定的时间点
    cv.wait_until(ulck, std::chrono::system_clock::now() + std::chrono::seconds(1));
#endif
    std::cout << "子线程等待结束" << std::endl;
}

int main() {
    std::cout << "创建子线程" << std::endl;
    std::thread t(func);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << "子线程可以往下执行" << std::endl;
    cv.notify_one();
    if (t.joinable()) {
        t.join();
    }
    return 0;
}
```

+ 例子2
一个安全队列

```c++
#include <iostream>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>

template <class T>
class MyQueue {
    private:
        std::queue<T> que_;
        std::mutex mtx_;
        std::condition_variable cv_;
    public:
        MyQueue() = default;
        ~MyQueue() = default;
        void push(T que) {
            std::unique_lock<std::mutex> ulck(mtx_);
            que_.push(std::move(que));
            cv_.notify_one();
        }

        void wait_pop(T &value) {
            std::unique_lock<std::mutex> ulck(mtx_);
            std::cout << "等待数据\n";
            cv_.wait(ulck, [&]() ->bool {
                return !que_.empty();
            });
            std::cout << "有数据\n";
            value = que_.front();
            que_.pop();
        }

};


MyQueue<int> mq;

void func() {
    while (true) {
        int i = 0;
        mq.wait_pop(i);
        std::cout << i << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(2));
    }
}

int main() {
    std::thread t(func);
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mq.push(1);
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mq.push(2);
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mq.push(3);
    if (t.joinable()) {
        t.join();
    }
    return 0;
}
```

## 🔐 自旋锁

> 自旋锁属于属于busy-waiting类型锁，它避免了操作系统进程调度和线程切换(用户进程和内核切换的消耗)，通常适用在时间极短的情况，所以如果一个线程持有锁的时间比较短，那么就可以使用自旋锁。

> 但如果长时间上锁，自旋锁会非常耗费性能。线程持有锁时间越长，则持有锁的线程被 OS调度程序中断的风险越大。如果发生中断情况，那么其它线程将保持旋转状态(反复尝试获取锁)，而持有锁的线程并不打算释放锁，导致结果是无限期推迟，直到持有锁的线程可以完成并释放它为止。
自旋锁避免了操作系统进程调度和线程切换，通常适用在时间极短的情况，因此操作系统的内核经常使用自旋锁。

> 自旋锁的目的是占着CPU资源不进行释放，等到获取锁立即进行处理。如果自旋执行时间太长，会有大量的线程处于自旋状态占用CPU资源，进而会影响整体系统的性能，因此可以给自旋锁设定一个自旋时间，等时间一到立即释放自旋锁，注意： 持有自旋锁的线程在sleep之前应该释放自旋锁以便其他线程可以获得该自旋锁。

> **_实际上许多其他类型的锁在底层使用了自旋锁实现，例如多数互斥锁在试图获取锁的时候会先自旋一小段时间，然后才会休眠。如果在持锁时间很长的场景下使用自旋锁，则会导致CPU在这个线程的时间片用尽之前一直消耗在无意义的忙等上，造成计算资源的浪费。_**

+ 实现方式-CAS(Compare and Swap)

思路如下（如下的代码只是用来理清楚实现原理，不能用于项目）

```c++
class SpinLock {
    private：
        bool flag_;
        bool CAS(bool &M, bool &E, bool D) {
            if (M == E) {
                std::swap(M, D);
                return  true;
            }
            return false;
        }
    public:
        SpinLock() : flag_(false){}
        ~SpinLock() = default;
        void Lock(){
            bool expect = false;
            // flag_ == false说明没有人持有这个锁，得到这个锁后马上把flag_置为true;这样别的线程想要Lock的时候发现锁被占有了就会一直轮询
            while (!CAS(flag_, expect, true)) {
                expect = false;
            }
        }

        void Unlock() {
            flag_ = false;
        }
};
```

+ 例子1（使用std::atomic<bool>实现）


```c++
#include <atomic>

class SpinLock {
public:
  SpinLock() : flag_(false) {}
  ~SpinLock() = default;

  void Lock() {
    bool expect = false;
    while (!flag_.compare_exchange_weak(expect, true)) {
      expect = false;
    }
  }

  void Unlock() { flag_.store(false); }

private:
  std::atomic<bool> flag_;
};

#include <iostream>
#include <thread>

SpinLock slck;

int main() {
  std::thread t1([&]() {
    while (true) {
      slck.Lock();
      std::cout << "线程1持有锁\n";
      slck.Unlock();
    }
  });

  std::thread t2([&]() {
    while (true) {
      slck.Lock();
      std::cout << "线程2持有锁\n";
      slck.Unlock();
    }
  });

  if (t1.joinable()) {
    t1.join();
  }
  if (t2.joinable()) {
    t2.join();
  }
  return 0;
}
```

+ 例子2（使用std::atomic_flag实现）

```c++
#include <atomic>

class SpinLock {
private:
  std::atomic_flag flag_;

public:
  SpinLock() : flag_(ATOMIC_FLAG_INIT) {}
  ~SpinLock() = default;
  void Lock() {
    // 获得锁 (test_and_set为设置当前lock为true，并返回lock设置之前的值)
    while (flag_.test_and_set(std::memory_order_acquire));
  }
  void Unlock() {
    // 释放锁 (clear为设置lock的值为false)
    flag_.clear(std::memory_order_release);
  }
};

#include <iostream>
#include <thread>

SpinLock slck;

int main() {
  std::thread t1([&]() {
    while (true) {
      slck.Lock();
      std::cout << "线程1持有锁\n";
      slck.Unlock();
    }
  });

  std::thread t2([&]() {
    while (true) {
      slck.Lock();
      std::cout << "线程2持有锁\n";
      slck.Unlock();
    }
  });

  if (t1.joinable()) {
    t1.join();
  }
  if (t2.joinable()) {
    t2.join();
  }
  return 0;
}
```


## 🔐 读写锁

读写锁又叫多读单写锁(multi-reader single-writer lock)，细分为公平锁,读优先锁,写优先锁,优先级锁, 实现思路如下:

+ 公平锁：实用队列来管理锁，先到先得

+ 读优先：这种场合用于读少写多的情况，只要有读请求则优先处理读请求

+ 写优先：这种场合用于读多写少的情况，只要有写请求则优先处理写请求

+ 优先级锁：带有优先级的锁，优先级高的锁先获取资源，可以使用set管理请求资源的锁，并按照优先级排序

下面是c语言版本的读写锁，这里不作详细介绍:

```c
#include <pthread.h>
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);   /* 销毁RW lock */
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);       /* 初始化RW lock */
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;   /* 直接赋值方式初始化RW lock */
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);    /* 取得读锁，进入read-mode */
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); /* 尝试取得读锁，失败立即返回  */
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); /* 取得写锁，进入write-mode */
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);    /* 尝试取得写锁，失败立即返回  */
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);    /* 释放读/写锁 */```c
```

c++11本身是没有读写锁的，可以自己实现，下面是一个公平锁的例子，采用条件锁和互斥锁实现。

```c++
#include <condition_variable>
#include <mutex>

class SharedMutex {
  public:
    SharedMutex() = default;
    SharedMutex(const SharedMutex &) = delete;
    SharedMutex &operator=(const SharedMutex &) = delete;
    ~SharedMutex() = default;
    void read_lock() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return 0 == exclusive_num_; });
        ++shared_num_;
    }
    void read_unlock() {
        std::unique_lock<std::mutex> lock(mutex_);
        --shared_num_;
        if (0 == shared_num_) {
            cv_.notify_one();
        }
    }
    void write_lock() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return 0 == shared_num_ && 0 == exclusive_num_; });
        exclusive_num_ = 1;
    }
    void write_unlock() {
        std::unique_lock<std::mutex> lock(mutex_);
        exclusive_num_ = 0;
        cv_.notify_all();
    }

  private:
    int shared_num_{ 0 };
    int exclusive_num_{ 0 };
    std::mutex mutex_;
    std::condition_variable cv_;
};

template <typename T>
class ReadLock {
  public:
    explicit ReadLock(T &mutex) : mutex_(mutex) { mutex_.read_lock(); }
    ReadLock(const ReadLock &) = delete;
    ReadLock &operator=(const ReadLock &) = delete;
    ~ReadLock() { mutex_.read_unlock(); }

  private:
    T &mutex_;
};

template <typename T>
class WriteLock {
  public:
    explicit WriteLock(T &mutex) : mutex_(mutex) { mutex_.write_lock(); }
    WriteLock(const WriteLock &) = delete;
    WriteLock &operator=(const WriteLock &) = delete;
    ~WriteLock() { mutex_.write_unlock(); }

  private:
    T &mutex_;
};

使用:
#include "SharedMutex.h"
#include <iostream>
#include <thread>

SharedMutex shared_mutex;
std::thread t1, t2, t3;
int A = 0;

int main(int argc, char **argv) {
  t1 = std::move(std::thread([&]() {
    while (true) {
      {
        ReadLock<SharedMutex> lck(shared_mutex);
        std::cout << "Thread1: read A : " << A << std::endl;
      }
      std::this_thread::sleep_for(std::chrono::seconds(1));
    }
  }));
  t2 = std::move(std::thread([&]() {
    while (true) {
      {
        ReadLock<SharedMutex> lck(shared_mutex);
        std::cout << "Thread2: read A : " << A << std::endl;
      }
      std::this_thread::sleep_for(std::chrono::seconds(1));
    }
  }));
  t3 = std::move(std::thread([&]() {
    while (true) {
      std::this_thread::sleep_for(std::chrono::seconds(1));
      {
        WriteLock<SharedMutex> lck(shared_mutex);
        std::cout << "Thread3: write A: " << ++A << std::endl;
      }
    }
  }));

  t1.join();
  t2.join();
  t3.join();
  while (1) {
    std::this_thread::sleep_for(std::chrono::seconds(5));
  }
  return 0;
}
```



## 🔐 递归锁

有这么一个场景

```c++

std::mutex mtx;

void func1() {
    mtx.lock();
    // do something
    mtx.unlock();
}

void func2() {
    mtx.lock();
    func1();
    // do something
    mtx.unlock();
}

```

当出现上面这种情况的时候，就会陷入死锁，递归锁就可以解决这个问题，它允许在同一线程反复加锁，只要加锁次数和解锁次数相等就不会陷入死锁；

+ 例子

```c++
#include <mutex>
#include <thread>
#include <iostream>

std::recursive_mutex rmtx;

void func1() {
    mtx.lock();
    std::cout << "func1\n";
    mtx.unlock();
}

void func2() {
    mtx.lock();
    std::cout << "func2\n";
    func1();
    mtx.unlock();
}

int main () {
    std::thread t1(func1);
    std::thread t2(func2);

    if (t1.joinable()) {
        t1.join();
    }
    if (t2.joinable()) {
        t2.join();
    }

    return 0;
}

```
