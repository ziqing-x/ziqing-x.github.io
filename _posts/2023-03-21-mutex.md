---
title: c++å¸¸ç”¨é”ä»‹ç»
tags: [é”]
category: c++
description: äº’æ–¥é”ã€æ¡ä»¶é”ã€è‡ªæ—‹é”ã€è¯»å†™é”ã€é€’å½’é”
---

## æ¦‚è¿°
c++å¸¸è§çš„é”æœ‰äº’æ–¥é”ã€æ¡ä»¶é”ã€è‡ªæ—‹é”ã€è¯»å†™é”ã€é€’å½’é”ï¼›é€šè¿‡è¿™ç¯‡æ–‡ç« ï¼Œä½ åº”è¯¥æŒæ¡ä»€ä¹ˆåœºæ™¯ä½¿ç”¨ä»€ä¹ˆé”ã€‚

## ğŸ” äº’æ–¥é”
### std::mutex

+ å¤´æ–‡ä»¶ 

```c++ 
#include <mutex>
```

+ å¸¸ç”¨æˆå‘˜æ–¹æ³•

```c++
lock(); // åŠ é”ï¼Œå¹¶ä¸”åªæœ‰ä¸€ä¸ªçº¿ç¨‹è·å¾—é”çš„æ‰€æœ‰æƒï¼Œå®ƒå…·æœ‰é˜»å¡çº¿ç¨‹çš„ä½œç”¨
try_lock(); // å’Œlockçš„åŒºåˆ«å°±æ˜¯ï¼Œä¸é˜»å¡ï¼Œä¼šç«‹å³è¿”å›
unlock(); // è§£é”
```

+ ä¾‹å­

```c++
#include <mutex>
#include <iostream>
#include <thread>
#include <unistd.h>

std::mutex mtx;

int main() {
    std::thread t1([](){
        sleep(2); // ä¼‘çœ 2ç§’ï¼Œè®©t2çº¿ç¨‹å…ˆæ‹¿åˆ°é”
        while (true) {
            mtx.lock(); // t2æˆ–è€…t3æŒæœ‰é”æœªè§£é”t1å°±ä¼šä¸€ç›´é˜»å¡
            std::cout<< "t1å·²ä¸Šé”\n";
            mtx.unlock();
            std::cout<< "t1å·²è§£é”\n";
        }
    });

    std::thread t2([](){
        // ä¸Šé”åæ°¸è¿œä¸è§£é”
        mtx.lock();
        while (true){
            std::cout<< "t2å·²ä¸Šé”\n";
            sleep(1);
        }
        mtx.unlock();
    });
    
    std::thread t3([](){
        while (true) {
            // å°è¯•ä¸Šé”ï¼Œç«‹åˆ»è¿”å›ï¼Œä¸é˜»å¡ï¼Œå¦‚æœæˆåŠŸè¿”å›trueï¼Œå¤±è´¥è¿”å›false
            auto ret = mtx.try_lock();
            if (ret) {
                std::cout<< "t3å·²ä¸Šé”\n";
                mtx.unlock();
                std::cout<< "t3å·²è§£é”\n";
            } else {
                std::cout<< "t3ä¸Šé”å¤±è´¥\n";
            }
            sleep(1);
        }
    });

    if (t1.joinable()) {
        t1.join();
    }
    if (t2.joinable()) {
        t2.join();
    }
    if (t3.joinable()) {
        t3.join();
    }

    return 0;
}

```

### std::lock_guard
lock_guard ä½¿ç”¨äº† RAII æŠ€æœ¯ï¼Œåœ¨æ„é€ çš„æ—¶å€™ä¸Šé”ï¼Œææ„çš„æ—¶å€™unlock()ï¼Œç”¨æ¥è§£å†³std::mutexåœ¨lock()æˆ–è€…try_lock()æˆåŠŸåè¿˜æœªæ¥å¾—åŠunlock()å°±é€€å‡ºæˆ–è€…å¼‚å¸¸çš„é—®é¢˜ã€‚

+ å¤´æ–‡ä»¶ 

```c++ 
#include <mutex>
```

+ ä¾‹å­

```c++
#include <mutex>
#include <iostream>
#include <thread>
#include <unistd.h>

std::mutex mtx;

int main() {
    std::thread t1([](){
        sleep(2); // ä¼‘çœ 2ç§’ï¼Œè®©t2çº¿ç¨‹å…ˆæ‹¿åˆ°é”
        while (true) {
            std::lock_guard<std::mutex> lck(mtx);// t2æˆ–è€…t3æŒæœ‰é”æœªè§£é”t1å°±ä¼šä¸€ç›´é˜»å¡
            std::cout<< "t1å·²ä¸Šé”\n";
            break;
        }
        std::cout<< "t1å·²è§£é”\n";
    });

    std::thread t2([](){
        while (true){
            std::lock_guard<std::mutex> lck(mtx);
            std::cout<< "t2å·²ä¸Šé”\n";
            sleep(5);
            break;

        }
        std::cout<< "t2å·²è§£é”\n";
    });
    
    if (t1.joinable()) {
        t1.join();
    }
    if (t2.joinable()) {
        t2.join();
    }

    return 0;
}
```

### std::unique_lock
lock_guardåªèƒ½åœ¨ææ„çš„æ—¶å€™è§£é”ï¼Œä¸æä¾›unlockæ¥å£ï¼Œä¸å¤Ÿæ–¹ä¾¿ï¼Œunique_lockæä¾›lockå’Œunlockæ¥å£ï¼Œæ›´çµæ´»ï¼Œä½†æ˜¯unique_lockæ¯”lock_guardæ•ˆç‡ä¸Šå·®ä¸€ç‚¹ï¼Œå†…å­˜å ç”¨å¤šä¸€ç‚¹ã€‚
+ å¤´æ–‡ä»¶

```c++ 
#include <mutex>
```

+ å¸¸ç”¨æˆå‘˜æ–¹æ³•

```c++
lock();
unlock();
```

+ ä¾‹å­

```c++
#include <iostream>
#include <mutex>
#include <thread>
#include <unistd.h>

std::mutex mtx;

int main() {
    std::thread t([](){
        while (true) {
            std::unique_lock<std::mutex> lck(mtx);
            std::cout << "tå·²ä¸Šé”\n";
            lck.unlock();
            std::cout << "tä¸´æ—¶è§£é”\n";
            lck.lock();
            std::cout << "tå†æ¬¡ä¸Šé”\n";
            break;
        }
        std::cout << "tè§£é”\n";
    });
    
    usleep(100); // è®©å­çº¿ç¨‹å…ˆæ‹¿åˆ°é”
    std::unique_lock<std::mutex> lck(mtx);
    std::cout << "Hello world" << std::endl;
    if (t.joinable()) {
        t.join();
    }
    return 0;
}
```

***
## ğŸ” æ¡ä»¶é”
### std::condition_variable
æ¡ä»¶å˜é‡ï¼ŒæŸä¸€ä¸ªçº¿ç¨‹å› ä¸ºæŸä¸ªæ¡ä»¶æœªæ»¡è¶³æ—¶å¯ä»¥ä½¿ç”¨æ¡ä»¶å˜é‡ä½¿è¯¥çº¿ç¨‹å¤„äºé˜»å¡çŠ¶æ€ï¼Œä¸€æ—¦æ¡ä»¶æ»¡è¶³ï¼Œä»¥â€œä¿¡å·é‡â€çš„æ–¹å¼å”¤é†’ä¸€ä¸ªå› ä¸ºè¯¥æ¡ä»¶è€Œè¢«é˜»å¡çš„çº¿ç¨‹ã€‚åªèƒ½ä¸äº’æ–¥é”é…åˆä½¿ç”¨
+ å¤´æ–‡ä»¶ 

```c++ 
#include <condition_variable>
#include <mutex>
```

+ å¸¸ç”¨æˆå‘˜æ–¹æ³•

```c++
wait(); // é˜»å¡å½“å‰çº¿ç¨‹ç›´åˆ°æ¡ä»¶æ»¡è¶³è¢«å”¤é†’
wait_for(); // é˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å”¤é†’æ¡ä»¶å˜é‡æˆ–åœ¨æŒ‡å®šçš„è¶…æ—¶æ—¶é—´ä¹‹å
wait_until(); // é˜»å¡å½“å‰çº¿ç¨‹ï¼Œç›´åˆ°å”¤é†’æ¡ä»¶å˜é‡æˆ–ç›´åˆ°è¾¾åˆ°æŒ‡å®šçš„æ—¶é—´ç‚¹ä¸ºæ­¢
notify_one(); // é€šçŸ¥ä¸€ä¸ªæ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹
notify_all(); // é€šçŸ¥æ‰€æœ‰æ­£åœ¨ç­‰å¾…çš„çº¿ç¨‹
```

+ ä¾‹å­1
å¤šçº¿ç¨‹åŒæ­¥

```c++
#include <iostream>
#include <thread>
#include <mutex>
#include <condition_variable>

std::mutex mtx;
std::condition_variable cv;

void func() {
    std::unique_lock<std::mutex> ulck(mtx);
    std::cout << "å­çº¿ç¨‹ç­‰å¾…ä¸­..." << std::endl;
#if 1 // ä¸€ç›´é˜»å¡ç­‰å¾…
    cv.wait(ulck);
#elif 0// åªç­‰å¾…20ç§’
    cv.wait_for(ulck, std::chrono::seconds(20) == std::cv_status::timeout);
#else // ç­‰åˆ°æŒ‡å®šçš„æ—¶é—´ç‚¹
    cv.wait_until(ulck, std::chrono::system_clock::now() + std::chrono::seconds(1));
#endif
    std::cout << "å­çº¿ç¨‹ç­‰å¾…ç»“æŸ" << std::endl;
}

int main() {
    std::cout << "åˆ›å»ºå­çº¿ç¨‹" << std::endl;
    std::thread t(func);
    std::this_thread::sleep_for(std::chrono::seconds(3));
    std::cout << "å­çº¿ç¨‹å¯ä»¥å¾€ä¸‹æ‰§è¡Œ" << std::endl;
    cv.notify_one();
    if (t.joinable()) {
        t.join();
    }
    return 0;
}
```

+ ä¾‹å­2
ä¸€ä¸ªå®‰å…¨é˜Ÿåˆ—

```c++
#include <iostream>
#include <queue>
#include <mutex>
#include <thread>
#include <condition_variable>

template <class T>
class MyQueue {
    private:
        std::queue<T> que_;
        std::mutex mtx_;
        std::condition_variable cv_;
    public:
        MyQueue() = default;
        ~MyQueue() = default;
        void push(T que) {
            std::unique_lock<std::mutex> ulck(mtx_);
            que_.push(std::move(que));
            cv_.notify_one();
        }

        void wait_pop(T &value) {
            std::unique_lock<std::mutex> ulck(mtx_);
            std::cout << "ç­‰å¾…æ•°æ®\n";
            cv_.wait(ulck, [&]() ->bool {
                return !que_.empty();
            });
            std::cout << "æœ‰æ•°æ®\n";
            value = que_.front();
            que_.pop();
        }

};


MyQueue<int> mq;

void func() {
    while (true) {
        int i = 0;
        mq.wait_pop(i);
        std::cout << i << std::endl;
        std::this_thread::sleep_for(std::chrono::seconds(2));
    }
}

int main() {
    std::thread t(func);
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mq.push(1);
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mq.push(2);
    std::this_thread::sleep_for(std::chrono::seconds(2));
    mq.push(3);
    if (t.joinable()) {
        t.join();
    }
    return 0;
}
```

## ğŸ” è‡ªæ—‹é”

> è‡ªæ—‹é”å±äºå±äºbusy-waitingç±»å‹é”ï¼Œå®ƒé¿å…äº†æ“ä½œç³»ç»Ÿè¿›ç¨‹è°ƒåº¦å’Œçº¿ç¨‹åˆ‡æ¢(ç”¨æˆ·è¿›ç¨‹å’Œå†…æ ¸åˆ‡æ¢çš„æ¶ˆè€—)ï¼Œé€šå¸¸é€‚ç”¨åœ¨æ—¶é—´æçŸ­çš„æƒ…å†µï¼Œæ‰€ä»¥å¦‚æœä¸€ä¸ªçº¿ç¨‹æŒæœ‰é”çš„æ—¶é—´æ¯”è¾ƒçŸ­ï¼Œé‚£ä¹ˆå°±å¯ä»¥ä½¿ç”¨è‡ªæ—‹é”ã€‚

> ä½†å¦‚æœé•¿æ—¶é—´ä¸Šé”ï¼Œè‡ªæ—‹é”ä¼šéå¸¸è€—è´¹æ€§èƒ½ã€‚çº¿ç¨‹æŒæœ‰é”æ—¶é—´è¶Šé•¿ï¼Œåˆ™æŒæœ‰é”çš„çº¿ç¨‹è¢« OSè°ƒåº¦ç¨‹åºä¸­æ–­çš„é£é™©è¶Šå¤§ã€‚å¦‚æœå‘ç”Ÿä¸­æ–­æƒ…å†µï¼Œé‚£ä¹ˆå…¶å®ƒçº¿ç¨‹å°†ä¿æŒæ—‹è½¬çŠ¶æ€(åå¤å°è¯•è·å–é”)ï¼Œè€ŒæŒæœ‰é”çš„çº¿ç¨‹å¹¶ä¸æ‰“ç®—é‡Šæ”¾é”ï¼Œå¯¼è‡´ç»“æœæ˜¯æ— é™æœŸæ¨è¿Ÿï¼Œç›´åˆ°æŒæœ‰é”çš„çº¿ç¨‹å¯ä»¥å®Œæˆå¹¶é‡Šæ”¾å®ƒä¸ºæ­¢ã€‚
è‡ªæ—‹é”é¿å…äº†æ“ä½œç³»ç»Ÿè¿›ç¨‹è°ƒåº¦å’Œçº¿ç¨‹åˆ‡æ¢ï¼Œé€šå¸¸é€‚ç”¨åœ¨æ—¶é—´æçŸ­çš„æƒ…å†µï¼Œå› æ­¤æ“ä½œç³»ç»Ÿçš„å†…æ ¸ç»å¸¸ä½¿ç”¨è‡ªæ—‹é”ã€‚

> è‡ªæ—‹é”çš„ç›®çš„æ˜¯å ç€CPUèµ„æºä¸è¿›è¡Œé‡Šæ”¾ï¼Œç­‰åˆ°è·å–é”ç«‹å³è¿›è¡Œå¤„ç†ã€‚å¦‚æœè‡ªæ—‹æ‰§è¡Œæ—¶é—´å¤ªé•¿ï¼Œä¼šæœ‰å¤§é‡çš„çº¿ç¨‹å¤„äºè‡ªæ—‹çŠ¶æ€å ç”¨CPUèµ„æºï¼Œè¿›è€Œä¼šå½±å“æ•´ä½“ç³»ç»Ÿçš„æ€§èƒ½ï¼Œå› æ­¤å¯ä»¥ç»™è‡ªæ—‹é”è®¾å®šä¸€ä¸ªè‡ªæ—‹æ—¶é—´ï¼Œç­‰æ—¶é—´ä¸€åˆ°ç«‹å³é‡Šæ”¾è‡ªæ—‹é”ï¼Œæ³¨æ„ï¼š æŒæœ‰è‡ªæ—‹é”çš„çº¿ç¨‹åœ¨sleepä¹‹å‰åº”è¯¥é‡Šæ”¾è‡ªæ—‹é”ä»¥ä¾¿å…¶ä»–çº¿ç¨‹å¯ä»¥è·å¾—è¯¥è‡ªæ—‹é”ã€‚

> **_å®é™…ä¸Šè®¸å¤šå…¶ä»–ç±»å‹çš„é”åœ¨åº•å±‚ä½¿ç”¨äº†è‡ªæ—‹é”å®ç°ï¼Œä¾‹å¦‚å¤šæ•°äº’æ–¥é”åœ¨è¯•å›¾è·å–é”çš„æ—¶å€™ä¼šå…ˆè‡ªæ—‹ä¸€å°æ®µæ—¶é—´ï¼Œç„¶åæ‰ä¼šä¼‘çœ ã€‚å¦‚æœåœ¨æŒé”æ—¶é—´å¾ˆé•¿çš„åœºæ™¯ä¸‹ä½¿ç”¨è‡ªæ—‹é”ï¼Œåˆ™ä¼šå¯¼è‡´CPUåœ¨è¿™ä¸ªçº¿ç¨‹çš„æ—¶é—´ç‰‡ç”¨å°½ä¹‹å‰ä¸€ç›´æ¶ˆè€—åœ¨æ— æ„ä¹‰çš„å¿™ç­‰ä¸Šï¼Œé€ æˆè®¡ç®—èµ„æºçš„æµªè´¹ã€‚_**

+ å®ç°æ–¹å¼-CAS(Compare and Swap)

æ€è·¯å¦‚ä¸‹ï¼ˆå¦‚ä¸‹çš„ä»£ç åªæ˜¯ç”¨æ¥ç†æ¸…æ¥šå®ç°åŸç†ï¼Œä¸èƒ½ç”¨äºé¡¹ç›®ï¼‰

```c++
class SpinLock {
    privateï¼š
        bool flag_;
        bool CAS(bool &M, bool &E, bool D) {
            if (M == E) {
                std::swap(M, D);
                return  true;
            }
            return false;
        }
    public:
        SpinLock() : flag_(false){}
        ~SpinLock() = default;
        void Lock(){
            bool expect = false;
            // flag_ == falseè¯´æ˜æ²¡æœ‰äººæŒæœ‰è¿™ä¸ªé”ï¼Œå¾—åˆ°è¿™ä¸ªé”åé©¬ä¸ŠæŠŠflag_ç½®ä¸ºtrue;è¿™æ ·åˆ«çš„çº¿ç¨‹æƒ³è¦Lockçš„æ—¶å€™å‘ç°é”è¢«å æœ‰äº†å°±ä¼šä¸€ç›´è½®è¯¢
            while (!CAS(flag_, expect, true)) {
                expect = false;
            }
        }

        void Unlock() {
            flag_ = false;
        }
};
```

+ ä¾‹å­1ï¼ˆä½¿ç”¨std::atomic<bool>å®ç°ï¼‰


```c++
#include <atomic>

class SpinLock {
public:
  SpinLock() : flag_(false) {}
  ~SpinLock() = default;

  void Lock() {
    bool expect = false;
    while (!flag_.compare_exchange_weak(expect, true)) {
      expect = false;
    }
  }

  void Unlock() { flag_.store(false); }

private:
  std::atomic<bool> flag_;
};

#include <iostream>
#include <thread>

SpinLock slck;

int main() {
  std::thread t1([&]() {
    while (true) {
      slck.Lock();
      std::cout << "çº¿ç¨‹1æŒæœ‰é”\n";
      slck.Unlock();
    }
  });

  std::thread t2([&]() {
    while (true) {
      slck.Lock();
      std::cout << "çº¿ç¨‹2æŒæœ‰é”\n";
      slck.Unlock();
    }
  });

  if (t1.joinable()) {
    t1.join();
  }
  if (t2.joinable()) {
    t2.join();
  }
  return 0;
}
```

+ ä¾‹å­2ï¼ˆä½¿ç”¨std::atomic_flagå®ç°ï¼‰

```c++
#include <atomic>

class SpinLock {
private:
  std::atomic_flag flag_;

public:
  SpinLock() : flag_(ATOMIC_FLAG_INIT) {}
  ~SpinLock() = default;
  void Lock() {
    // è·å¾—é” (test_and_setä¸ºè®¾ç½®å½“å‰lockä¸ºtrueï¼Œå¹¶è¿”å›lockè®¾ç½®ä¹‹å‰çš„å€¼)
    while (flag_.test_and_set(std::memory_order_acquire));
  }
  void Unlock() {
    // é‡Šæ”¾é” (clearä¸ºè®¾ç½®lockçš„å€¼ä¸ºfalse)
    flag_.clear(std::memory_order_release);
  }
};

#include <iostream>
#include <thread>

SpinLock slck;

int main() {
  std::thread t1([&]() {
    while (true) {
      slck.Lock();
      std::cout << "çº¿ç¨‹1æŒæœ‰é”\n";
      slck.Unlock();
    }
  });

  std::thread t2([&]() {
    while (true) {
      slck.Lock();
      std::cout << "çº¿ç¨‹2æŒæœ‰é”\n";
      slck.Unlock();
    }
  });

  if (t1.joinable()) {
    t1.join();
  }
  if (t2.joinable()) {
    t2.join();
  }
  return 0;
}
```


## ğŸ” è¯»å†™é”

è¯»å†™é”åˆå«å¤šè¯»å•å†™é”(multi-reader single-writer lock)ï¼Œç»†åˆ†ä¸ºå…¬å¹³é”,è¯»ä¼˜å…ˆé”,å†™ä¼˜å…ˆé”,ä¼˜å…ˆçº§é”, å®ç°æ€è·¯å¦‚ä¸‹:

+ å…¬å¹³é”ï¼šå®ç”¨é˜Ÿåˆ—æ¥ç®¡ç†é”ï¼Œå…ˆåˆ°å…ˆå¾—

+ è¯»ä¼˜å…ˆï¼šè¿™ç§åœºåˆç”¨äºè¯»å°‘å†™å¤šçš„æƒ…å†µï¼Œåªè¦æœ‰è¯»è¯·æ±‚åˆ™ä¼˜å…ˆå¤„ç†è¯»è¯·æ±‚

+ å†™ä¼˜å…ˆï¼šè¿™ç§åœºåˆç”¨äºè¯»å¤šå†™å°‘çš„æƒ…å†µï¼Œåªè¦æœ‰å†™è¯·æ±‚åˆ™ä¼˜å…ˆå¤„ç†å†™è¯·æ±‚

+ ä¼˜å…ˆçº§é”ï¼šå¸¦æœ‰ä¼˜å…ˆçº§çš„é”ï¼Œä¼˜å…ˆçº§é«˜çš„é”å…ˆè·å–èµ„æºï¼Œå¯ä»¥ä½¿ç”¨setç®¡ç†è¯·æ±‚èµ„æºçš„é”ï¼Œå¹¶æŒ‰ç…§ä¼˜å…ˆçº§æ’åº

ä¸‹é¢æ˜¯cè¯­è¨€ç‰ˆæœ¬çš„è¯»å†™é”ï¼Œè¿™é‡Œä¸ä½œè¯¦ç»†ä»‹ç»:

```c
#include <pthread.h>
int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);   /* é”€æ¯RW lock */
int pthread_rwlock_init(pthread_rwlock_t *restrict rwlock,const pthread_rwlockattr_t *restrict attr);       /* åˆå§‹åŒ–RW lock */
pthread_rwlock_t rwlock = PTHREAD_RWLOCK_INITIALIZER;   /* ç›´æ¥èµ‹å€¼æ–¹å¼åˆå§‹åŒ–RW lock */
int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);    /* å–å¾—è¯»é”ï¼Œè¿›å…¥read-mode */
int pthread_rwlock_tryrdlock(pthread_rwlock_t *rwlock); /* å°è¯•å–å¾—è¯»é”ï¼Œå¤±è´¥ç«‹å³è¿”å›  */
int pthread_rwlock_trywrlock(pthread_rwlock_t *rwlock); /* å–å¾—å†™é”ï¼Œè¿›å…¥write-mode */
int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);    /* å°è¯•å–å¾—å†™é”ï¼Œå¤±è´¥ç«‹å³è¿”å›  */
int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);    /* é‡Šæ”¾è¯»/å†™é” */```c
```

c++11æœ¬èº«æ˜¯æ²¡æœ‰è¯»å†™é”çš„ï¼Œå¯ä»¥è‡ªå·±å®ç°ï¼Œä¸‹é¢æ˜¯ä¸€ä¸ªå…¬å¹³é”çš„ä¾‹å­ï¼Œé‡‡ç”¨æ¡ä»¶é”å’Œäº’æ–¥é”å®ç°ã€‚

```c++
#include <condition_variable>
#include <mutex>

class SharedMutex {
  public:
    SharedMutex() = default;
    SharedMutex(const SharedMutex &) = delete;
    SharedMutex &operator=(const SharedMutex &) = delete;
    ~SharedMutex() = default;
    void read_lock() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return 0 == exclusive_num_; });
        ++shared_num_;
    }
    void read_unlock() {
        std::unique_lock<std::mutex> lock(mutex_);
        --shared_num_;
        if (0 == shared_num_) {
            cv_.notify_one();
        }
    }
    void write_lock() {
        std::unique_lock<std::mutex> lock(mutex_);
        cv_.wait(lock, [this] { return 0 == shared_num_ && 0 == exclusive_num_; });
        exclusive_num_ = 1;
    }
    void write_unlock() {
        std::unique_lock<std::mutex> lock(mutex_);
        exclusive_num_ = 0;
        cv_.notify_all();
    }

  private:
    int shared_num_{ 0 };
    int exclusive_num_{ 0 };
    std::mutex mutex_;
    std::condition_variable cv_;
};

template <typename T>
class ReadLock {
  public:
    explicit ReadLock(T &mutex) : mutex_(mutex) { mutex_.read_lock(); }
    ReadLock(const ReadLock &) = delete;
    ReadLock &operator=(const ReadLock &) = delete;
    ~ReadLock() { mutex_.read_unlock(); }

  private:
    T &mutex_;
};

template <typename T>
class WriteLock {
  public:
    explicit WriteLock(T &mutex) : mutex_(mutex) { mutex_.write_lock(); }
    WriteLock(const WriteLock &) = delete;
    WriteLock &operator=(const WriteLock &) = delete;
    ~WriteLock() { mutex_.write_unlock(); }

  private:
    T &mutex_;
};

ä½¿ç”¨:
#include "SharedMutex.h"
#include <iostream>
#include <thread>

SharedMutex shared_mutex;
std::thread t1, t2, t3;
int A = 0;

int main(int argc, char **argv) {
  t1 = std::move(std::thread([&]() {
    while (true) {
      {
        ReadLock<SharedMutex> lck(shared_mutex);
        std::cout << "Thread1: read A : " << A << std::endl;
      }
      std::this_thread::sleep_for(std::chrono::seconds(1));
    }
  }));
  t2 = std::move(std::thread([&]() {
    while (true) {
      {
        ReadLock<SharedMutex> lck(shared_mutex);
        std::cout << "Thread2: read A : " << A << std::endl;
      }
      std::this_thread::sleep_for(std::chrono::seconds(1));
    }
  }));
  t3 = std::move(std::thread([&]() {
    while (true) {
      std::this_thread::sleep_for(std::chrono::seconds(1));
      {
        WriteLock<SharedMutex> lck(shared_mutex);
        std::cout << "Thread3: write A: " << ++A << std::endl;
      }
    }
  }));

  t1.join();
  t2.join();
  t3.join();
  while (1) {
    std::this_thread::sleep_for(std::chrono::seconds(5));
  }
  return 0;
}
```



## ğŸ” é€’å½’é”

æœ‰è¿™ä¹ˆä¸€ä¸ªåœºæ™¯

```c++

std::mutex mtx;

void func1() {
    mtx.lock();
    // do something
    mtx.unlock();
}

void func2() {
    mtx.lock();
    func1();
    // do something
    mtx.unlock();
}

```

å½“å‡ºç°ä¸Šé¢è¿™ç§æƒ…å†µçš„æ—¶å€™ï¼Œå°±ä¼šé™·å…¥æ­»é”ï¼Œé€’å½’é”å°±å¯ä»¥è§£å†³è¿™ä¸ªé—®é¢˜ï¼Œå®ƒå…è®¸åœ¨åŒä¸€çº¿ç¨‹åå¤åŠ é”ï¼Œåªè¦åŠ é”æ¬¡æ•°å’Œè§£é”æ¬¡æ•°ç›¸ç­‰å°±ä¸ä¼šé™·å…¥æ­»é”ï¼›

+ ä¾‹å­

```c++
#include <mutex>
#include <thread>
#include <iostream>

std::recursive_mutex rmtx;

void func1() {
    mtx.lock();
    std::cout << "func1\n";
    mtx.unlock();
}

void func2() {
    mtx.lock();
    std::cout << "func2\n";
    func1();
    mtx.unlock();
}

int main () {
    std::thread t1(func1);
    std::thread t2(func2);

    if (t1.joinable()) {
        t1.join();
    }
    if (t2.joinable()) {
        t2.join();
    }

    return 0;
}

```
