---
title: c++中的23种设计模式
tags: [设计模式]
category: c++
description: 如何设计c++代码？
---

## 前言
为什么需要设计模式?

+ 代码重用性 (相同功能的代码，不用多次编写)

+ 可读性 (编程规范性, 便于其他程序员的阅读和理解)

+ 可扩展性 (当需要增加新的功能时，非常的方便，称为可维护)

+ 可靠性 (当我们增加新的功能后，对原来的功能没有影响)

+ 使程序呈现高内聚，低耦合的特性


## 📐  设计模式的基本原则

### 开闭原则

对扩展开放，对修改关闭。让程序更稳定更灵活。

### 单一职责原则

一个类应该只负责一项职责。

### 依赖倒置原则

依赖于抽象(接口)，不要依赖具体的实现(类)，也就是针对接口编程。让项目拥有变化的能力。

### 接口隔离原则

应当尽量为客户端提供小的单独的接口，而不是提供大的总的接口。系统有更高的灵活性。

### 迪米特法则

又叫最少知识原则，一个对象应当对其他对象尽可能少的了解。更好地扩展性。

### 里氏替换原则

软件里面，把父类都替换成它的子类，程序的行为没有变化，构建扩展性更好的系统。

### 组合/聚合原则

尽量使用组合聚合来达到复用效果，尽量少使用继承。继承一定程度上是牺牲了封装性来达到复用的效果的，这样有时是得不偿失的。

## 📐  创建型设计模式（6种）

单例模式、简单工厂模式、 工厂模式、抽象工厂模式、建造者模式、原型模式

### 1、单例模式

单例模式分为懒汉式和饿汉式；

+ 饿汉式，实例在进入main()函数之前就已经存在了.

+ 懒汉式，第一次获取实例的时候才分配内存。

设计思路:

+ 1、构造函数私有化；

+ 2、提供一个全局的静态方法；
  

懒汉式

```c++
#include <iostream>
#include <string>

template <class T>
class Singleton {
public:
  template <typename... Args>
  static T &GetInstance(Args &&...args) {
    static T instance(std::forward<Args>(args)...);
    return instance;
  }

  Singleton(const Singleton&) = delete;
  Singleton& operator=(const Singleton&) = delete;

protected:
  Singleton() = default;
  ~Singleton() = default;
};

class Person : public Singleton<Person> {
public:
  Person(const std::string &name, int age) {
    name_ = name;
    age_ = age;
  }

  void ShowInfo() {
    std::cout << "姓名: " << name_ << "\n";
    std::cout << "年龄: " << age_ << "\n";
  }

private:
  std::string name_;
  int age_{0};
};

int main() {
  Person::GetInstance("xxx", 15).ShowInfo();
  return 0;
}

```

饿汉式

```c++
#include <iostream>
#include <memory>
#include <mutex>
#include <string>

template <class T> 
class Singleton {
public:
  template <typename... Args> 
  static std::unique_ptr<T> &GetInstance(Args &&...args) {
    std::call_once(flag_, [&]() {
      instance_ = std::make_unique<T>(std::forward<Args>(args)...);
    });
    return instance_;
  }

  Singleton(const Singleton&) = delete;
  Singleton& operator=(const Singleton&) = delete;

protected:
  Singleton() = default;
  ~Singleton() = default;

protected:
  static std::unique_ptr<T> instance_;
  static std::once_flag flag_; // 保证多线程调用时只make_unique一次
};

template <class T> std::unique_ptr<T> Singleton<T>::instance_= nullptr;
template <class T> std::once_flag Singleton<T>::flag_;


class Person : public Singleton<Person> {
public:
  Person(const std::string &name, int age) {
    name_ = name;
    age_ = age;
  }

  void ShowInfo() {
    std::cout << "姓名: " << name_ << "\n";
    std::cout << "年龄: " << age_ << "\n";
  }

private:
  std::string name_;
  int age_{0};
};

int main() {
  Person::GetInstance("xxx", 15)->ShowInfo();
  return 0;
}
```

+ 简约版懒汉式

```c++
template<typename T>
class Singleton {
public:
    static T& GetInstance() {
        static T instance;
        return instance;
    }

    Singleton(const Singleton&) = delete;
    Singleton& operator=(const Singleton&) = delete;

protected:
    Singleton() = default;
    ~Singleton() = default;
};
```

### 2、简单工厂模式

简单工厂模式又叫做静态工厂模式，用一个工厂类来创建其他类的实例，被创建的实例通常都具有共同的父类。

+ 例子

```c++
#include "Factory.h"
#include "ConcreteProductA.h"
#include "ConcreteProductB.h"

Product* Factory::CreateProduct(const std::string &name){
  if (!name.compare("A"))
	{
		return new ConcreteProductA();
	}
	else if(!name.compare("B") )
	{
		return new ConcreteProductB();
	}
	return  nullptr;
}
```

### 3、工厂模式

### 4、抽象工厂模式

### 5、建造者模式

### 6、原型模式


## 📐  结构型设计模式

## 📐  行为型设计模式

